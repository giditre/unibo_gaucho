import json
from pyzabbix import ZabbixAPI
from ipaddress import IPv4Address

#===

import copy
from enum import Enum, IntEnum

#===

import shlex
import subprocess
import re
from enum import IntEnum
from abc import ABCMeta, abstractmethod

import slp


class ZabbixNode:
  def __init__(self, node_id="", node_name="", node_ipv4=None, is_available=""):
    self.__node_id = node_id
    self.__node_name = node_name
    self.__node_ipv4 = IPv4Address(node_ipv4)
    self.__is_available = is_available

  def get_node_id(self):
    return self.__node_id

  def set_node_id(self, node_id) :
    self.__node_id = node_id

  def get_node_name(self):
    return self.__node_name

  def set_node_name(self, node_name) :
    self.__node_name = node_name

  def get_node_ipv4(self):
    return self.__node_ipv4

  def set_node_ipv4(self, node_ipv4) :
    self.__node_ipv4 = node_ipv4

  def get_is_available(self):
    return self.__is_available

  def set_is_available(self, is_available) :
    self.__is_available = is_available

  def __repr__(self):
    return "ZabbixNode ID {} - name {} - IPv4 {} - available {}".format(
      self.__node_id, self.__node_name, self.__node_ipv4, self.__is_available)

  def to_dict(self):
    return {
      "node_id": self.__node_id,
      "node_name": self.__node_name,
      "node_ipv4": self.__node_ipv4,
      "is_available": self.__is_available
    }

  def to_json(self):
    return json.dumps( { k: str(v) for k, v in self.to_dict().items() } )

  @staticmethod
  def validate_node_id(node):
    assert isinstance(node, (ZabbixNode, str)), "Nodes must be provided as ZabbixNode or str, not {}".format(type(node))
    if isinstance(node, ZabbixNode):
      # "node" is a ZabbixNode object and we need to extract the ID
      return node.get_node_id()
    elif isinstance(node, str):
      # "node" is already an ID
      return node
    else:
      raise TypeError # TODO G: rischiamo davvero di arrivare qui?

class ZabbixController:
  def __init__(self, url='http://localhost/zabbix/', user='Admin', password='zabbix'):
    self.__url = url
    self.__user = user
    self.__password = password
    self.__zapi = ZabbixAPI(url=self.__url, user=self.__user, password=self.__password)

    self.__item_field_list = [ "hostid", "itemid", "name", "lastclock", "lastvalue", "units" ] # TODO G: meglio fare un Enum?
    self.__field_to_metric_name_dict = {
      "hostid": "node_id",
      "itemid": "metric_id",
      "name": "metric_name",
      "lastclock": "timestamp",
      "lastvalue": "value",
      "units": "unit"
    }

  def __repr__(self):
    return "ZabbixController on URL {} with user {}".format(self.__url, self.__user)

  def get_url(self):
    return self.__url

  def get_nodes(self, server_name="Zabbix Server"):
    # fields=["hostid", "name", "available"]

    # z_node_list = [ ZabbixNode( *[ h[f] for f in fields ] ) for h in self.zapi.host.get(search={"name": server_name}, excludeSearch=True) ]

    z_node_list = []

    for h in self.__zapi.host.get(search={"name": server_name}, excludeSearch=True):
      # print(h)

      h_id = h["hostid"]
      h_name = h["name"]
      h_avail = h["available"]
      
      h_ip = None
      for i in self.__zapi.hostinterface.get(hostids= h_id):
        h_ip = i["ip"]
        break

      z_node = ZabbixNode(h_id, h_name, h_ip, h_avail)
      z_node_list.append(z_node)

    return z_node_list

  def get_node_by_ip(self, ip):
    if not isinstance(ip, IPv4Address):
      ip = IPv4Address(ip)
    for zn in self.get_nodes():
      if zn.get_node_ipv4() == ip:
        return zn
    return None

  def get_item_id_by_node_and_item_name(self, node, item_name): # TODO G: maybe find better name
    node_id = ZabbixNode.validate_node_id(node)
    item_list = self.__zapi.item.get(hostids=node_id, search={"name": item_name})
    if len(item_list) == 1:
      return item_list[0]["itemid"]
    else:
      # TODO G: how to handle this case?
      # print(item_list)
      raise ValueError 

  # def get_item_id_by_node(self, node):
  #   node_id = ZabbixNode.validate_node_id(node)


  def get_measurements_by_node(self, node, item_name_list=[]):
    return self.get_measurements_by_node_list([node], item_name_list)

  def get_measurements_by_node_list(self, node_list, item_name_list=[]):
    node_id_list = []
    for node in node_list:
      node_id = ZabbixNode.validate_node_id(node)
      node_id_list.append(node_id)

    measurements = {}

    if not item_name_list:
      measurements.update( { item["itemid"]: { m: item[f] for f, m in self.__field_to_metric_name_dict.items() } for item in self.__zapi.item.get(hostids=node_id_list) } )

    else:
      for item_name in item_name_list:
        measurements.update( { item["itemid"]: { m: item[f] for f, m in self.__field_to_metric_name_dict.items() } for item in self.__zapi.item.get(hostids=node_id_list, search={"name": item_name}, searchWildcardsEnabled=True) } )

    return measurements

  def get_measurements_by_item_id(self, item_id):
    return self.get_measurements_by_item_id_list([item_id])

  def get_measurements_by_item_id_list(self, item_id_list):
    measurements = { item["itemid"]: { m: item[f] for f, m in self.__field_to_metric_name_dict.items() } for item in self.__zapi.item.get(itemids=item_id_list) }
    return measurements


# if __name__ == "__main__":
#   def truncated_str(elem):
#     s = str(elem)
#     if len(s) < 600:
#       return s
#     else:
#       return s[:600] + " [...]"

#   # instantiate Zabbix controller
#   zc = ZabbixController()

#   print("List of all known nodes:")
#   print(zc.get_nodes())
#   print()

#   node_ip = "192.168.10.120"
#   print("Details on node having address {}:".format(node_ip))
#   node1 = zc.get_node_by_ip(node_ip)
#   print("As a string: ", node1)
#   print("As a dict: ", node1.to_dict())
#   print("As a JSON: ", node1.to_json())
#   node_ip = "192.168.10.123"
#   print("Details on node having address {}:".format(node_ip))
#   node2 = zc.get_node_by_ip(node_ip)
#   print("As a string: ", node2)
#   print("As a dict: ", node2.to_dict())
#   print("As a JSON: ", node2.to_json())
#   print()

#   print("Different ways to get measurements:")
#   print("--- by node, e.g.: get_measurements_by_node(node1)")
#   print(truncated_str(zc.get_measurements_by_node(node1)))
#   print("--- by node list, e.g.: get_measurements_by_node_list([node1, node2])")
#   print(truncated_str(zc.get_measurements_by_node_list([node1, node2])))
#   print("--- by node or node list with item names, e.g.: get_measurements_by_node_list([node1, node2], [\"CPU utilization\", \"Memory utilization\"])")
#   print(truncated_str(zc.get_measurements_by_node_list([node1, node2], ["CPU utilization", "Memory utilization"])))
#   print("--- by item ID, e.g.: get_measurements_by_item_id(\"30254\")")
#   print(truncated_str(zc.get_measurements_by_item_id("30254")))
#   print("--- by item ID list, e.g.: get_measurements_by_item_id_list([\"30251\",\"31007\"])")
#   print(truncated_str(zc.get_measurements_by_item_id_list(["30251","31007"])))
#   print()

#   print("Getting item ID by node and item name, e.g.: get_item_id_by_node_and_item_name(node1, \"CPU utilization\")")
#   print(zc.get_item_id_by_node_and_item_name(node1, "CPU utilization"))

#TODO M: ricompilare OpenSLP per correggere alcuni bug: https://github.com/openslp-org/openslp
#TODO M: Se serve: mettere controllo dei parametri di input nei vari metodi (soprattutto i costruttori)
#TODO M: Se serve: override __repr__ di tutte le classi?
#TODO M: aggiungere zc al costruttore di Service

#========================================================

# from forch.forch_utils_slp import SLPController

#from https://docs.python.org/3/library/enum.html
class MetricType(Enum):
  CPU = "CPU utilization"
  RAM = "Memory utilization"

class MeasurementRetrievalMode(IntEnum):
  SERVICE = 1
  NODE = 2
  METRIC = 3

class Service:
  __zc = None
    
  class _ServiceNode:
    class _Metric:
      def __init__(self, id="", m_type=MetricType.CPU, timestamp="", value="", unit=""):
        self.__id = id
        self.__type = m_type
        self.__timestamp = timestamp
        self.__value = value
        self.__unit = unit

      def __eq__(self, obj):
        if isinstance(obj, self.__class__):
          return self.__id == obj.get_id()
        return False
      
      def get_id(self):
        return self.__id
      def set_id(self, id):
        self.__id = id
        
      def get_name(self):
        return self.__name
      def set_name(self, name):
        self.__name = name
        
      def get_timestamp(self):
        return self.__timestamp
      def set_timestamp(self, timestamp):
        self.__timestamp = timestamp
        
      def get_value(self):
        return self.__value
      def set_value(self, value):
        self.__value = value
      
      def get_unit(self):
        return self.__unit
      def set_unit(self, unit):
        self.__unit = unit
        
      def update(self, measurements_dict):
        # measurements_dict is expected to be a dictionary formatted as {'30254': {'node_id': '10313', 'metric_id': '30254', 'metric_name': 'CPU utilization', 'timestamp': '0', 'value': '0', 'unit': '%'}}
        m_id = self.get_id()
        assert m_id in measurements_dict, "Measurement of metric {} is not in provided measurements!".format(m_id)
        self.set_timestamp(measurements_dict[m_id]["timestamp"])
        self.set_value(measurements_dict[m_id]["value"])
        if self.get_unit() == "":
          self.set_unit(measurements_dict[m_id]["unit"])
        
        
      # def retrieve_measurements(self): # TODO G: tenere questo metodo o no?
      #   # method to refresh the value of a single metric
      #   measurements = Service.__zc.get_measurements_by_item_id(self.get_id()) # TODO G: si fa così ad invocare __zc da dentro una sottoclasse?
      #   # populate the data structure
      #   m_id = self.get_id()
      #   if m_id in measurements:
      #     metric.set_timestamp(measurements[m_id]["timestamp"])
      #     metric.set_value(measurements[m_id]["value"])
      #     metric.set_unit(measurements[m_id]["unit"]) # TODO G: inutile settare ogni volta le unità (?)
      #   else:
      #     # TODO G: come gestire il caso in cui un nodo abbia una metrica che però non compare tra le misure? è possibile?
      #     pass      
  
    # 0xffff = slp.SLP_LIFETIME_MAXIMUM
    def __init__(self, id="", name="", available=False, ipv4=None, port=None, lifetime=0xffff, metrics_list=[]):
      assert isinstance(ipv4, IPv4Address) and ipv4 != None, "Parameter ipv4 must me an IPv4Address!"
      
      self.__id = id
      self.__name = name
      self.__available = available
      self.__ip = ipv4
      self.__port = port
      self.__lifetime = lifetime
      # self.__metrics_list = get_lst(metric) # TODO M: da rivedere
      # "metrics" is expected to be formatted as { metric_id: metric_type }
      self.__metrics_list = metrics_list

    def __eq__(self, obj):
      if isinstance(obj, self.__class__):
        return self.__id == obj.get_id()
      return False
      
    def get_id(self):
 	    return self.__id 
    def set_id(self, id):
      self.__id = id

    def get_name(self):
      return self.__name    
    def set_name(self, name):
      self.__name = name

    def get_available(self):
      return self.__available    
    def set_available(self, available):
      self.__available = available

    def get_ip(self):
      return self.__ip
    def set_ip(self, ipv4):
      assert isinstance(ipv4, IPv4Address), "Parameter ipv4 must me an IPv4Address!"
      self.__ip = ipv4

    def get_port(self):
      return self.__port
    def set_port(self, port):
      self.__port = port

    def get_lifetime(self):
      return self.__lifetime
    def set_lifetime(self, lifetime):
      self.__lifetime = lifetime

    def get_metrics_list(self):
      return self.__metrics_list
      
    #TODO G: Valutare setter di self.__metrics_list
    
    def get_metric_by_name(self, m_type):
      assert isinstance(m_type, MetricType), "Parameter m_type must be a MetricType!"
      #return next((metric for metric in self.__metric_list if metric.get_name() == m_type), None) # not used because readability    
      for metric in self.get_metrics_list():
        if metric.get_name() == m_type:
          return metric
      return None
      
    # def retrieve_measurements(self): # TODO G: tenere questo metodo o no?
    #   # method to refresh the value of all metrics of a node
    #   measurements = Service.__zc.get_measurements_by_item_id([m.get_id() for m in self.get_metrics_list()]) # TODO G: si fa così ad invocare __zc da dentro una sottoclasse?
    #   # populate the data structure
    #   for metric in node.get_metrics_list():
    #     m_id = metric.get_id()
    #     if m_id in measurements:
    #       metric.set_timestamp(measurements[m_id]["timestamp"])
    #       metric.set_value(measurements[m_id]["value"])
    #       metric.set_unit(measurements[m_id]["unit"]) # TODO G: inutile settare ogni volta le unità (?)
    #     else:
    #       # TODO G: come gestire il caso in cui un nodo abbia una metrica che però non compare tra le misure? è possibile?
    #       pass

  def __init__(self, name="", protocol="", node_list=[], id="", category="", descr=""):
    assert self.__zc != None, "Zabbix controller not assigned yet. Call before Service.set_zabbix_controller()"

    for node in node_list:
      assert isinstance(node, self._ServiceNode), "Parameter node_list must be a list of ServiceNode!"

    self.__name = name
    self.__protocol = protocol
    self.__node_list = node_list
    self.__id = id
    self.__category = category
    self.__descr = descr
 
  def __eq__(self, obj):
    if isinstance(obj, self.__class__):
      return self.__id == obj.get_id()
    return False

  def get_name(self):
    return self.__name
  def set_name(self, name):
    self.__name = name

  def get_protocol(self):
    return self.__protocol
  def set_protocol(self, protocol):
    self.__protocol = protocol

  def get_node_list(self):
    return self.__node_list
  # def __set_node_list(self, node_list):
  #   self.__node_list = node_list

  def get_id(self):
    return self.__id
  def set_id(self, id):
    self.__id = id

  def get_category(self):
    return self.__category
  def set_category(self, category):
    self.__category = category

  def get_descr(self):
    return self.__descr
  def set_descr(self, descr):
    self.__descr = descr

  # This is the convergence point between Zabbix and SLP
  def add_node(self, ipv4=None, port=None):
    assert isinstance(ipv4, list) and ipv4 != None, "Parameter node_ip_list must be a list of IPv4Address objects!"

    node = self.__zc.get_node_by_ip(ipv4)
    node_dict = node.to_dict()
    node_dict["available"] = node_dict["available"] == "1"
    
    # create metrics list for this node
    m_list = [ self._ServiceNode._Metric(id=self.__zc.get_item_id_by_node_and_item_name(node_dict["node_id"], elem.value), m_type=elem) for elem in MetricType ]
    
    # instatiate new ServiceNode and append it to node list
    self.__node_list.append(self._ServiceNode(id=node_dict["node_id"], name=node_dict["name"], available=node_dict["available"], ipv4=ipv4, port=port, metrics_list=m_list))
       
    # TODO M: vedere se ritornare qualcosa

  # TODO M: se questo metodo è usato solo da SLPController, decidere se tenerlo qui o metterlo li
  # Useful links:
  # https://stackoverflow.com/questions/9835762/how-do-i-find-the-duplicates-in-a-list-and-create-another-list-with-them
  # https://stackoverflow.com/questions/9542738/python-find-in-list
  @classmethod
  def aggregate_nodes_of_equal_services(cls, service_list): #TODO M: trovare nome migliore
    assert isinstance(service_list, list), "Parameter service_list must be a list!"
    ret_list = []
    for srvc in service_list:
      assert isinstance(srvc, Service), "Parameter service_list must contains Service objects!"
      if srvc not in ret_list:
        ret_list.append(srvc)
      else:
        new_node_list = ret_list[ret_list.index(srvc)].get_node_list()
        new_node_list.extend(srvc.get_node_list())
        new_node_list = list(set(new_node_list))
        ret_list[ret_list.index(srvc)] = cls(name=srvc.get_name(), protocol=srvc.get_protocol(), node_list=new_node_list, id=srvc.get_id(), category=srvc.get_category(), descr=srvc.get_descr())
    return ret_list

  @staticmethod
  def get_zabbix_controller():
    return Service.__zc
  @staticmethod
  def set_zabbix_controller(zc):
    assert isinstance(zc, ZabbixController), "Parameter zc must be a ZabbixController object!"
    Service.__zc = zc

  def get_node_by_metric(self, m_type=MetricType.CPU, check="min"):
    metric_list = []
    
    #get list of a specified metric from the node list
    for node in self.__node_list:
      metric = node.get_metric_by_name(m_type)
      if metric != None:
        metric_list.append(metric)
        
    if not metric_list: #if list is empty
      return None
    
    #Sorting metrics by value (https://docs.python.org/3/howto/sorting.html)
    if check == "min":
      # res_metric = sorted(metric_list, key=lambda metric: metric.get_value())[0]
      res_metric = min(metric_list, key=lambda metric: metric.get_value())
    elif check == "max":
      # res_metric = sorted(metric_list, key=lambda metric: metric.get_value())[-1]
      res_metric = max(metric_list, key=lambda metric: metric.get_value())
    else:
      return None
      
    #find the node that owns the result metric and return it
    for node in self.__node_list:
      #in questo if ci fa comodo l'override di __eq__ fatto nella classe Metric
      if res_metric == node.get_metric_by_name(m_type):
        return node
        
  def retrieve_measurements(self, mode=MeasurementRetrievalMode.SERVICE):
    assert isinstance(mode, MeasurementRetrievalMode), "Parameter mode must be a MeasurementRetrievalMode!"
    # check retrieval mode
    if mode == MeasurementRetrievalMode.SERVICE:
      # retrieve all measurements (of the defined metrics) of all nodes associated to this Service
      # get list of known nodes (it will be used multiple times)
      node_list = self.get_node_list()
      # retrieve all measurements for all nodes for all defined metric types
      # this returns a dictionary formatted as {'30254': {'node_id': '10313', 'metric_id': '30254', 'metric_name': 'CPU utilization', 'timestamp': '0', 'value': '0', 'unit': '%'}}
      measurements = self.__zc.get_measurements_by_node_list([node.get_id() for node in node_list], item_name_list=[item.value for item in MetricType])
      # populate the data structure
      for node in node_list:
        for metric in node.get_metrics_list():
          metric.update(measurements)
    elif mode == MeasurementRetrievalMode.NODE:
      # refresh the value of all metrics of a node
      for node in self.get_node_list(): 
        measurements = self.__zc.get_measurements_by_item_id([m.get_id() for m in node.get_metrics_list()])
        # populate the data structure
        for metric in node.get_metrics_list():
          metric.update(measurements)
    elif mode == MeasurementRetrievalMode.METRIC:
      # refresh the value of a single metric
      for node in self.get_node_list():
        for metric in node.get_metrics_list():
          measurements = self.__zc.get_measurements_by_item_id(metric.get_id())
          metric.update(measurements)
    else:
      # should never happen
      pass

class ServiceCache:
  def __init__(self):        
    self.__slp_ctrl = SLPController(SLPAgentType)
    self.__services_list = []
    self.refresh()
    
  def get_list(self):
    return copy.deepcopy(self.__services_list)
    
  def clear(self):
    self.__services_list = []
    
  def refresh(self):
    self.clear()    
    self.__services_list = self.__slp_ctrl.find_all_services()

# if __name__ == "__main__":
#   # def truncated_str(elem):
#   #   s = str(elem)
#   #   if len(s) < 600:
#   #     return s
#   #   else:
#   #     return s[:600] + " [...]"

#   # instantiate Zabbix controller
#   zc = ZabbixController()

#   Service.set_zabbix_controller(zc)

#====================================================

# RECALL:
# slp.SLP_LIFETIME_DEFAULT = 10800
# slp.SLP_LIFETIME_MAXIMUM = 65535

class SLPAgentType(IntEnum):
    UA = 1
    SA = 2
    DA = 3

# This class exposes methods dedicated to the different types of agents.
# If a method is used in a wrong agent context, Python will return errors
# saying that one or more methods are not defined
# More or less SLPController is a _SLPAgent wrapper
class SLPController:
  #TODO M: se la storia degli abstract da troppi problemi toglierla. Proviamo a tenerla per il momento. Override dentro _SLPActiveAgent nuovamente abstract necessario?
  class _SLPAgent(metaclass=ABCMeta):
    def __init__(self, slp_handler=None):
      self.__hslp = slp_handler
      if self.__hslp == None:
        self.__hslp = self.__hslp = slp.SLPOpen("en", False) #TODO M: valutare se usare OpenSLP in maniera sincrona o asincrona. Con False è sincrona

    def __del__(self):
      slp.SLPClose(self.__hslp)

    def get_handler(self):
      return self.__hslp

    # This method is intended as abstract
    @abstractmethod
    def get_type(self):
      return

  # TODO M: decidere se poter avere più demoni (max uno per ogni agente) o averne soltanto uno e basta. N.B.: credo che SLP non lo preveda. Cercare di capirlo
  # This class is used like a sort of interface
  class _SLPActiveAgent(_SLPAgent):
    __daemon_process = None

    def __init__(self,slp_handler=None):
      self.start_daemon() #TODO M: controllare valore di ritorno?
      super().__init__(slp_handler)

    def __del__(self):
      super().__del__()
      self.stop_daemon()

    def daemon_is_running(self):
      if self.__daemon_process != None:
        if self.__daemon_process.poll() == None:
          return True      
      return False
    
    def start_daemon(self,optns_str=""):#,parameters):
      if self.daemon_is_running():
        raise_error(self.__class__, "Daemon is already running!")
        #return False

      cmd_str = "sudo slpd"

      if optns_str != "":
        cmd_str = " " + optns_str

      self.__daemon_process = subprocess.Popen(shlex.split(cmd_str))

      return True
      
    def stop_daemon(self):
      if not self.daemon_is_running():
        return False
      self.__daemon_process.terminate() # TODO M: controllare se è davvero terminato ed eventualmente fare .kill()? Per adesso ci fidiamo.
      return True
      
    def kill_daemon(self):
      if not self.daemon_is_running():
        return False
      self.__daemon_process.kill()
      return True
      
  class _UA(_SLPAgent):
    # Warning! static vars
    _discovered_service_types_list = []
    _discovered_service_tuple_list = []
    _discovered_attributes_list = []

    def get_type(self):
      return SLPAgentType.UA
      
    # Expected inputs: string, {key1:value1, key2:value2, ...}, string
    # prints, count and rqst_type are only for debug
    @staticmethod
    def __rqsts_callback_core(param_dict,errcode,rqst_type=""):
      # global count
      rv = False
      if errcode == slp.SLP_OK:
        for key in param_dict:
          print("{}: {}".format(key,param_dict[key]), end=", ")
        # count += 1
        rv = True
      elif errcode == slp.SLP_LAST_CALL:
        # if count == 0:
        #   print(rqst_type + ": Nothing found")
        # else:
        #   print("Found " + str(count) + " " + rqst_type)
        pass # TODO G: fix count
      else:
        print("Error: " + str(errcode))
      return rv
    
    @staticmethod
    def __srvc_types_callback(h, srvc_type, errcode, cookie_data):
      SLPController._UA._discovered_service_types_list = []
      res = SLPController._UA.__rqsts_callback_core({"srvc_type":srvc_type},str(errcode),"service types")
      if res == True:
        SLPController._UA._discovered_service_types_list.append(srvc_type)
      return res

    @staticmethod
    def __service_callback(h, srvurl, lifetime, errcode, cookie_data):
      SLPController._UA._discovered_service_tuple_list = []
      res = SLPController._UA.__rqsts_callback_core({"url":srvurl, "timeout":lifetime},str(errcode),"service")
      if res == True:
        SLPController._UA._discovered_service_tuple_list.append((srvurl,lifetime))
      return res

    @staticmethod
    def __attr_callback(h, attrs, errcode, cookie_data):
      SLPController._UA._discovered_attributes_list = []
      res = SLPController._UA.__rqsts_callback_core({"attrs":attrs},str(errcode),"attribute lists")
      if res == True:
        SLPController._UA._discovered_attributes_list.append(attrs)
      return res

    def find_srvc_types(self):
      try:
        slp.SLPFindSrvTypes(self.__hslp, None, None, self.__srvc_types_callback, None)
      except RuntimeError as e:
        print("Error discovering the service type: " + str(e))
        return None
      return self._discovered_service_types_list
      
    def find_service(self, service_type):
      try:
        slp.SLPFindSrvs(self.__hslp, service_type, None, None, self.__service_callback, None)
      except RuntimeError as e:
        print("Error discovering the service: " + str(e))
        return None
      return self._discovered_service_tuple_list

    def find_attr_list(self, srvurl):
      try:
        slp.SLPFindAttrs(self.__hslp, srvurl, None, None, self.__attr_callback, None)
      except RuntimeError as e:
        print("Error discovering the service attributes: " + str(e))
        return None
      return self._discovered_attributes_list
  
  class _SA(_SLPActiveAgent):
    def get_type(self):
      return SLPAgentType.SA

    @staticmethod
    def __reg_callback(h, errcode, data):
      if errcode != slp.SLP_OK:
        print("Error de/registering service: " + str(errcode))
      return None

    def register_service(self, srvurl, attrs="", lifetime=slp.SLP_LIFETIME_DEFAULT):
      try:
        slp.SLPReg(self.__hslp, srvurl, lifetime, None, attrs, True, self.__reg_callback, None)
      except RuntimeError as e:
        print("Error registering new service: " + str(e))

    def deregister_service(self, srvurl):
      try:
        slp.SLPDereg(self.__hslp, srvurl, self.__reg_callback, None)
      except RuntimeError as e:
        print("Error deregistering service: " + str(e))

  class _DA(_SLPActiveAgent):
    def __init__(self,slp_handler=None):
      slp.SLPSetProperty("net.slp.isDA", "true")
      super().__init__()

    def get_type(self):
      return SLPAgentType.DA

  # Begin of SLPController class code

  _ATTRIBUTES_SEPARATOR = ','

  def __init__(self,agent,slp_handler = None):
    if agent == SLPAgentType.UA:
      #TODO M: in teoria queste non dovrebbero essere necessarie perchè il protocollo dovrebbe trovare il DA locale e parlare solo con lui in unicast. Verificare
      #slp.SLPSetProperty("net.slp.interfaces", "127.0.0.1")
      #slp.SLPSetProperty("net.slp.DAAddresses", "127.0.0.1")
      self.__agent = self._UA(slp_handler)
    elif agent == SLPAgentType.SA:
      self.__agent = self._SA(slp_handler)
    elif agent == SLPAgentType.DA:
      self.__agent = self._DA(slp_handler)
    else:
      raise_error(__class__,'Passed an invalid agent parameter')

  def get_handler(self):
    return self.__agent.get_handler()

  def get_agent_type(self):
    return self.__agent.get_type()

  @staticmethod
  def __service_to_slp_service(service):
    assert isinstance(service, Service), "Parameter service must be a Service() object!"
    srvc_type = "service:" + service.get_name() + ":" + service.get_protocol()

    srvurl_list = []
    lifetime_list = []
    for node in service.get_node_list():
      srvurl_list.append(srvc_type + "://" + node.get_ip() + ":" + node.get_port())
      lifetime_list.append(node.get_lifetime())

    attrs = "id=" + service.get_id() + SLPController._ATTRIBUTES_SEPARATOR + "category=" + service.get_category() + SLPController._ATTRIBUTES_SEPARATOR + "descr=" + service.get_descr()

    return (srvurl_list, attrs, lifetime_list)

  @staticmethod
  def __srvurl_to_service(srvurl):
    srvc_type, host_ipv4, host_port = slp.SLPParseSrvURL(srvurl)
    assert re.match("^service(:[a-zA-Z0-9.]+){2,2}$", srvc_type), "Service type is not custom. It must contain at least two ':'"
    srvc = Service(name=srvc_type.split(":")[1], protocol=srvc_type.split(":")[2])
    srvc.add_node(ipv4=host_ipv4, port=host_port)
    # TODO: maybe check return value se Zabbix non trova il nodo che ha trovato SLP e in caso exception?
    return srvc

  @staticmethod
  def __attrs_to_service(attrs_str):
    tmp_attrs_list = attrs_str.split(SLPController._ATTRIBUTES_SEPARATOR)

    attrs_list = []
    for attr in tmp_attrs_list:
      attrs_list.extend(attr.slip("="))

    srvc = Service()

    for i in range(0, len(attrs_list), 2):
      if attrs_list[i] == "id":
        srvc.set_id(attrs_list[i+1])
      elif attrs_list[i] == "category":
        srvc.set_category(attrs_list[i+1])
      elif attrs_list[i] == "descr":
        srvc.set_descr(attrs_list[i+1])

    return srvc
      
  def find_all_services(self):
    srvc_types_list = self.__agent.find_srvc_types()
    srvc_types_list = list(set(srvc_types_list)) #if equals elements are returned keep only one of them

    found_srvs_list = []
    for srvc_type in srvc_types_list:
      found_srvs_list.extend(self.__agent.find_service(srvc_type))
    # TODO M: verificare se è possibile che la lista contenga elementi uguali. Nel caso toglierli
    # NOTE: Il TODO precedente dovrebbe essere automaticamente risolto nell'istruzione di return

    srvs_dict = {}
    for i, srvc_tuple in enumerate(found_srvs_list):
      srvs_dict.update({srvc_tuple[0]:self.__agent.find_attr_list(srvc_tuple[0]), ("lifetime#" + str(i)):srvc_tuple[1]})

    srvs_list = []
    for key in srvs_dict:
      srvc = None
      if key.split("#")[0] != "lifetime":
        srvc = self.__srvurl_to_service(key) # in this case key = srvurl

        tmp_srvc = self.__attrs_to_service(srvs_dict[key])
        srvc.set_id(tmp_srvc.get_id())
        srvc.set_category(tmp_srvc.get_category())
        srvc.set_descr(tmp_srvc.get_descr())
      else:
        assert len(srvc.get_node_list()) == 1, "In theory here we have only one node associated to a service"
        srvc.get_node_list()[0].set_lifetime(srvs_dict[key]) # in this case key = lifetime
        srvs_list.append(srvc)

    return Service.aggregate_nodes_of_equal_services(srvs_list)

  def register_service(self, service):
    srvurl_list, attrs, lifetime_list = self.__service_to_slp_service(service)
    for i, srvurl in enumerate(srvurl_list):
      self.__agent.register_service(srvurl, attrs, lifetime_list[i])

  def deregister_service(self, service):
    srvurl_list = self.__service_to_slp_service(service)[0]
    for srvurl in srvurl_list:
      self.__agent.deregister_service(srvurl)

#=========================================

def get_lst(item):
  if item is None:
    return item
  return [item] if not isinstance(item, list) else item

def raise_error(class_name, msg=""):
  try:
    raise NameError(class_name)
  except NameError:
    print(msg)
    raise